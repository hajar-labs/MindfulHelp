# -*- coding: utf-8 -*-
"""chatbot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V5jQuMgmZgmOdh01X0iijbIoBRk9Iw-S
"""

import spacy
import textblob
from transformers import pipeline

class EmotionDetector:
    def __init__(self):
        # Load spaCy language model
        self.nlp = spacy.load('en_core_web_sm')

        # Initialize sentiment analysis pipeline
        self.sentiment_analyzer = pipeline('sentiment-analysis')

        # Emotion mapping
        self.emotion_map = {
            'positive': {
                'emotions': ['joy', 'excitement', 'hope', 'gratitude'],
                'intensity_levels': ['mild', 'moderate', 'intense']
            },
            'negative': {
                'emotions': ['sadness', 'anger', 'fear', 'anxiety', 'frustration'],
                'intensity_levels': ['mild', 'moderate', 'severe']
            },
            'neutral': {
                'emotions': ['calm', 'contemplative', 'balanced'],
                'intensity_levels': ['low', 'medium']
            }
        }

    def detect_emotion(self, text):
        """
        Multilayered emotion detection with sentiment analysis

        Args:
            text (str): User input text

        Returns:
            dict: Comprehensive emotion analysis
        """
        # Basic sentiment analysis
        sentiment = self.sentiment_analyzer(text)[0]

        # TextBlob for additional sentiment nuance
        textblob_sentiment = TextBlob(text).sentiment

        # Advanced emotion categorization
        emotion_category = sentiment['label'].lower()
        possible_emotions = self.emotion_map.get(emotion_category, {}).get('emotions', [])
        intensity_levels = self.emotion_map.get(emotion_category, {}).get('intensity_levels', [])

        return {
            'primary_sentiment': sentiment['label'],
            'sentiment_score': sentiment['score'],
            'textblob_polarity': textblob_sentiment.polarity,
            'textblob_subjectivity': textblob_sentiment.subjectivity,
            'potential_emotions': possible_emotions,
            'recommended_intensity': intensity_levels[0] if intensity_levels else 'undefined',
            'detailed_analysis': {
                'emotional_complexity': len(possible_emotions),
                'sentiment_nuance': abs(textblob_sentiment.polarity)
            }
        }

# Usage example
def analyze_user_message(message):
    detector = EmotionDetector()
    emotion_profile = detector.detect_emotion(message)
    return emotion_profile

from typing import Dict, Any
import random

class TherapyConversationEngine:
    def __init__(self):
        # Conversation modes with response templates
        self.conversation_modes = {
            'therapist': {
                'responses': [
                    "Let's explore that feeling together.",
                    "Can you tell me more about what you're experiencing?",
                    "It sounds like you're processing something significant."
                ],
                'trigger_emotions': ['sadness', 'anxiety', 'fear']
            },
            'motivator': {
                'responses': [
                    "You've got this! Small steps lead to big changes.",
                    "I believe in your ability to overcome challenges.",
                    "Let's break this down into actionable steps."
                ],
                'trigger_emotions': ['hope', 'excitement']
            },
            'supportive_friend': {
                'responses': [
                    "I'm here for you, no judgment.",
                    "Sometimes it's okay to just feel what you're feeling.",
                    "You're stronger than you think."
                ],
                'trigger_emotions': ['neutral', 'calm']
            }
        }

        # User context tracking
        self.user_context = {}

    def select_conversation_mode(self, emotion_profile: Dict[str, Any]) -> str:
        """
        Dynamically select conversation mode based on emotion detection

        Args:
            emotion_profile (dict): Emotion analysis result

        Returns:
            str: Selected conversation mode
        """
        # Map emotion to conversation mode
        if emotion_profile['primary_sentiment'] == 'NEGATIVE':
            return 'therapist'
        elif emotion_profile['primary_sentiment'] == 'POSITIVE':
            return 'motivator'
        else:
            return 'supportive_friend'

    def generate_response(self, emotion_profile: Dict[str, Any], user_message: str) -> str:
        """
        Generate contextually appropriate response

        Args:
            emotion_profile (dict): Emotion analysis result
            user_message (str): Original user input

        Returns:
            str: AI-generated response
        """
        mode = self.select_conversation_mode(emotion_profile)
        selected_mode = self.conversation_modes[mode]

        # Select response
        response = random.choice(selected_mode['responses'])

        # Add personalization layer
        personalized_response = self._personalize_response(
            response,
            emotion_profile,
            user_message
        )

        return personalized_response

    def _personalize_response(self, base_response: str, emotion_profile: Dict, user_message: str) -> str:
        """
        Add personalization to responses

        Args:
            base_response (str): Original response template
            emotion_profile (dict): Emotion analysis
            user_message (str): Original user input

        Returns:
            str: Personalized response
        """
        personalization_hints = {
            'complex_emotion': "It seems like you're experiencing some complex emotions. ",
            'low_confidence': "I sense there might be some underlying concerns. ",
            'high_energy': "Your energy tells me you're ready for positive change. "
        }

        # Add personalization hint based on emotion complexity
        if emotion_profile['detailed_analysis']['emotional_complexity'] > 2:
            base_response = personalization_hints['complex_emotion'] + base_response

        return base_response

# Usage example
def process_user_interaction(emotion_detector, conversation_engine, user_message):
    # Detect emotion
    emotion_profile = emotion_detector.detect_emotion(user_message)

    # Generate response
    ai_response = conversation_engine.generate_response(
        emotion_profile,
        user_message
    )

    return {
        'emotion_profile': emotion_profile,
        'ai_response': ai_response
    }

from datetime import datetime
from typing import Dict, List
import uuid

class UserProgressTracker:
    def __init__(self, user_id):
        self.user_id = user_id
        self.journal_entries = []
        self.emotional_trends = {
            'daily_mood_scores': [],
            'emotion_distribution': {},
            'progress_markers': []
        }
        self.goals = []

    def add_journal_entry(self, content: str, emotion_profile: Dict) -> Dict:
        """
        Add a journal entry with emotional metadata

        Args:
            content (str): Journal entry text
            emotion_profile (dict): Emotion analysis result

        Returns:
            dict: Journal entry metadata
        """
        entry = {
            'id': str(uuid.uuid4()),
            'timestamp': datetime.now(),
            'content': content,
            'emotion_profile': emotion_profile,
            'mood_score': self._calculate_mood_score(emotion_profile)
        }

        self.journal_entries.append(entry)
        self._update_emotional_trends(entry)

        return entry

    def _calculate_mood_score(self, emotion_profile: Dict) -> float:
        """
        Calculate mood score based on emotion profile

        Args:
            emotion_profile (dict): Emotion analysis result

        Returns:
            float: Mood score (-1 to 1)
        """
        polarity = emotion_profile.get('textblob_polarity', 0)
        sentiment_score = emotion_profile.get('sentiment_score', 0.5)

        # Normalize mood score
        mood_score = (polarity + (sentiment_score * 2 - 1)) / 2
        return mood_score

    def _update_emotional_trends(self, entry: Dict):
        """
        Track emotional trends over time

        Args:
            entry (dict): Journal entry
        """
        mood_score = entry['mood_score']
        self.emotional_trends['daily_mood_scores'].append(mood_score)

        # Update emotion distribution
        for emotion in entry['emotion_profile'].get('potential_emotions', []):
            self.emotional_trends['emotion_distribution'][emotion] = \
                self.emotional_trends['emotion_distribution'].get(emotion, 0) + 1

    def set_personal_goal(self, goal: str, target_date: datetime):
        """
        Set and track personal goals

        Args:
            goal (str): Goal description
            target_date (datetime): Target completion date
        """
        goal_entry = {
            'id': str(uuid.uuid4()),
            'description': goal,
            'target_date': target_date,
            'status': 'in_progress',
            'created_at': datetime.now()
        }

        self.goals.append(goal_entry)
        return goal_entry

    def get_emotional_insights(self) -> Dict:
        """
        Generate emotional insights and recommendations

        Returns:
            dict: Emotional trend analysis and recommendations
        """
        insights = {
            'average_mood': sum(self.emotional_trends['daily_mood_scores']) / len(self.emotional_trends['daily_mood_scores']) if self.emotional_trends['daily_mood_scores'] else 0,
            'most_common_emotions': sorted(
                self.emotional_trends['emotion_distribution'].items(),
                key=lambda x: x[1],
                reverse=True
            )[:3],
            'recommendations': self._generate_personalized_recommendations()
        }

        return insights

    def _generate_personalized_recommendations(self) -> List[str]:
        """
        Generate personalized mental health recommendations

        Returns:
            list: Recommended actions
        """
        recommendations = [
            "Consider practicing daily mindfulness meditation",
            "Explore cognitive behavioral therapy techniques",
            "Maintain a consistent sleep schedule",
            "Engage in regular physical exercise"
        ]

        return recommendations

# Usage example
def track_user_progress(user_id, journal_entry, emotion_profile):
    tracker = UserProgressTracker(user_id)
    tracker.add_journal_entry(journal_entry, emotion_profile)
    insights = tracker.get_emotional_insights()
    return insights

from flask import Flask, request, jsonify
# Assuming emotion_detection.py is in the same directory or a recognized package

from pymongo import MongoClient
from datetime import datetime # importing datetime here

app = Flask(__name__)
mongo_client = MongoClient('your_mongodb_connection_string')
db = mongo_client['mental_health_db']

# Initialize core AI components
emotion_detector = EmotionDetector()
conversation_engine = TherapyConversationEngine()

@app.route('/ai-chat', methods=['POST'])
def ai_chat_endpoint():
    """
    Main AI chatbot interaction endpoint
    """
    data = request.json
    user_id = data.get('user_id')
    user_message = data.get('message')

    try:
        # Emotion detection
        emotion_profile = emotion_detector.detect_emotion(user_message)

        # Generate AI response
        ai_response = conversation_engine.generate_response(
            emotion_profile,
            user_message
        )

        # Track user progress
        progress_tracker = UserProgressTracker(user_id)
        journal_entry = progress_tracker.add_journal_entry(
            user_message,
            emotion_profile
        )

        # Store conversation in MongoDB
        conversation_log = {
            'user_id': user_id,
            'timestamp': datetime.now(), # Using datetime.now() directly
            'user_message': user_message,
            'ai_response': ai_response,
            'emotion_profile': emotion_profile
        }
        db.conversations.insert_one(conversation_log)

        return jsonify({
            'response': ai_response,
            'emotion_profile': emotion_profile,
            'journal_entry_id': journal_entry['id']
        }), 200

    except Exception as e:
        return jsonify({
            'error': str(e),
            'message': 'Error processing AI interaction'
        }), 500

if __name__ == '__main__':
    app.run(debug=True)

import requests
import json

url = 'http://127.0.0.1:5000/ai-chat'
data = {'user_id': 'your_user_id', 'message': 'Hello, how are you?'}
headers = {'Content-type': 'application/json'}

response = requests.post(url, data=json.dumps(data), headers=headers)
print(response.json())